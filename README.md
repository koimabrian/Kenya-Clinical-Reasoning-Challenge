# Kenya-Clinical-Reasoning-Challenge

https://zindi.africa/competitions/kenya-clinical-reasoning-challenge
https://zindi.africa/competitions/kenya-clinical-reasoning-challenge/data
https://zindi.africa/competitions/kenya-clinical-reasoning-challenge/discussions
https://zindi.africa/competitions/kenya-clinical-reasoning-challenge/leaderboard
https://zindi.africa/competitions/kenya-clinical-reasoning-challenge/submissions
https://www.path.org/who-we-are/programs/digital-health/large-language-models-for-health-equity/

ZINDI FILE
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/SampleSubmission.csv
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/manifest-37ac1cb3002e2d25fa612ef468101f6c20250407-27832-1ynal5z.json
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/test.csv
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/test_raw.csv
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/train.csv
https://github.com/koimabrian/Kenya-Clinical-Reasoning-Challenge/blob/main/train_raw.csv

I NEED A MODULAR SCALABLE STRUCTURE THAT I CAN BE ABLE TO TEST AND TRACK DIFFERENT MODELS PERFOMANCE AND ACCURACY LEVEL AND STORE RESULTS IN DB
FOLLOW ZINDI COMPETITION GUIDELINES RULES

TO DO:
Phase 1

1. Overview and Objectives
    Key Objectives:
2. Core Features and Functionality

3. High-Level Technical Stack Recommendations

4. Conceptual Data Model

5. Development Phases and Milestones

6. Potential Challenges and Solutions

Phase 2
Step 2 - Stub Out The Files
Phase 2
Step 2 - Stub Out The Files

You are now entering Phase 2 of the app development process. Your task is to create a stubbed-out project structure based on the masterplan.md file generated in Phase 1 and any drawings or wireframes provided by the user. Follow these instructions:

Begin by reviewing the masterplan.md file and any provided drawings or wireframes. Familiarize yourself with the app's overall structure, main features, and architectural decisions.
Create a high-level project structure with appropriate directories. This should reflect the app's architecture (e.g., frontend, backend, database) and main features.
For each major component or feature identified in the masterplan, create stub files with minimal, essential information. Include:
a. A brief comment at the top of each file describing its purpose
b. Add a comment  with the full filepath to the stub file. This prevents named conflicts when you create files with the same name in different directories.
c. Placeholder import statements for likely dependencies
d. Empty function or class declarations for key functionalities
e. TODO comments indicating where major logic will be implemented
In the stub files, do not include detailed implementations or actual code logic. The goal is to create a skeleton that can be easily expanded in Phase 3.
For the frontend (if applicable):
a. Create basic component files with empty component declarations
b. Stub out main pages or views
c. Include placeholder routing information
For the backend (if applicable):
a. Create stub files for main API endpoints or services
b. Include empty model definitions based on the data structure outlined in the masterplan
c. Stub out database connection file (if needed)
Create a basic README.md file with:
a. Project title and brief description
b. Placeholder sections for setup instructions, main features, and technology stack
If the app requires any configuration files (e.g., package.json, .gitignore), create these with minimal required information.
After creating the stubbed-out project structure, provide a summary of the created files and directories, explaining the purpose of each major component.
Ask the user if they would like to see the content of any specific stubbed files, and be prepared to show and explain them.
Remind the user that this is a minimal structure and that full implementation will occur in Phase 3.

Remember:

Keep all stubs minimal. Include just enough information to understand the file's purpose and its place in the overall structure.
Do not implement any actual logic or detailed code.
Use consistent naming conventions throughout the project structure.
If you're unsure about a specific structure or file, refer back to the masterplan or ask the user for clarification.

Begin by acknowledging that you're starting Phase 2 and ask the user if they're ready to see the stubbed-out project structure based on the masterplan.

Phase 3
Step 3 - Fully Code Out Overview (implementation)

You are now entering Phase 3 of the app development process. Your task is to transform the stubbed-out project structure from Phase 2 into fully functional, production-ready code. Follow these instructions:

1. Review the masterplan.md file, any provided drawings or wireframes, and the stubbed-out project structure from Phase 2.

2. Implement the full code for each stubbed file, following these guidelines:
   a. Write production-ready code at the level of a senior developer.
   b. Ensure the code is readable and well-structured.
   c. Consider the implications of your code choices before implementation.
   d. Add comments to explain complex logic or important design decisions.

3. If any details are missing or ambiguous, ask the user for clarification before proceeding with the implementation.

4. Focus on implementing core functionality first. Include light error handling and input validation where appropriate.

5. When dealing with third-party integrations or APIs mentioned in the masterplan, use your best judgment to implement them effectively.

6. For database operations and data persistence, choose appropriate methods based on the project requirements and your best judgment.

7. Do not implement extensive testing at this stage unless specifically requested by the user.

8. Do not focus on advanced scalability or performance optimizations unless they are critical for core functionality.

9. Security measures are out of scope for this phase unless explicitly mentioned in the masterplan as core functionality.

10. After implementing each major component or feature:
    a. Provide a brief summary of what was implemented.
    b. Explain any important design decisions or assumptions made.
    c. Highlight any areas where you had to make significant choices or interpretations.

11. Be prepared to show and explain any part of the implemented code if the user requests it.

12. After completing the implementation, provide a high-level summary of the work done, including:
    a. Overview of implemented features
    b. Any notable challenges encountered and how they were addressed
    c. Suggestions for next steps or areas that might need further refinement

13. Ask the user for feedback on the implemented code and be ready to make adjustments based on their input.

Remember:
- Strive for clean, efficient, and maintainable code.
- Ensure consistency in coding style and naming conventions throughout the project.
- While aiming for production-ready code, recognize that further refinement may be needed based on user feedback.
- If you encounter a situation not covered by these instructions, use your best judgment as a senior developer and explain your reasoning to the user.

Begin by acknowledging that you're starting Phase 3 and ask the user if they're ready to proceed with the full code implementation based on the stubbed-out structure from Phase 2.



